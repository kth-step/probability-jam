open HolKernel boolLib Parse bossLib pred_setTheory arithmeticTheory realTheory extrealTheory sigma_algebraTheory RealArith realSimps;

val _ = new_theory "testSigma";

(* the intersection algebra is an algebra *)

Theorem algebra_inter:
  !Ω A B. algebra (Ω,A)
  /\ algebra (Ω,B)
  ==> algebra (Ω, {M| M SUBSET Ω /\ M IN A /\ M IN B })
Proof
  REWRITE_TAC[algebra_def]
  >> rpt strip_tac
  >- fs[subset_class_def]
  >> fs[]
QED

Theorem sigma_algebra_inter:
  !Ω A B. sigma_algebra (Ω,A)
  /\ sigma_algebra (Ω,B)
  ==> sigma_algebra (Ω, {M| M SUBSET Ω /\ M IN A /\ M IN B })
Proof
  rw[sigma_algebra_def,algebra_inter]
  >- (
    rw[BIGUNION,SUBSET_DEF]
    >> drule_then drule $ iffLR SUBSET_DEF
    >> simp[SUBSET_DEF]
  )
  >> first_x_assum irule
  >> fs[SUBSET_DEF]
QED

Triviality BIGUNION_POW:
  !x X. BIGUNION x SUBSET X <=> x SUBSET POW X
Proof
  fs[BIGUNION_SUBSET,POW_DEF,SUBSET_DEF]
QED

(* the sigma algebra on X generated by collection of subsets is a sigma algebra *)

Theorem sigma_algebra_sigma_POW:
  !G X. G SUBSET POW X ==>
  sigma_algebra (X,subsets $ sigma X G)
Proof
  rw[sigma_algebra_def,sigma_def]
  >- (
    rw[algebra_def,subset_class_def]
    >> first_x_assum drule
    >> fs[IN_POW]
    >> fs[BIGUNION_POW]
  )
  (* or fs[SUBSET_BIGINTER] *)
  >> first_assum irule
  >> dxrule_then (assume_tac o SIMP_RULE (srw_ss()) []) $ iffLR SUBSET_BIGINTER
  >> first_x_assum $ drule_all
  >> fs[]
QED

(* the powerset of X is a sigma algebra on X *)

Theorem sigma_algebra_POW:
  !X. sigma_algebra (X,POW X)
Proof
  fs[sigma_algebra_def,BIGUNION_POW,IN_POW]
  >> rw[algebra_def,subset_class_def]
  >> fs[IN_POW]
QED

val _ = export_theory ();
